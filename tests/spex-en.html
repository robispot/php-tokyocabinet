<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="author" content="Mikio Hirabayashi" />
<meta name="keywords" content="Tokyo Cabinet, tokyocabinet, database, DBM" />
<meta name="description" content="Specifications of Tokyo Cabinet" />
<link rel="contents" href="./" />
<link rel="alternate" href="spex-ja.html" hreflang="en" title="the Japanese version" />
<link rel="stylesheet" href="common.css" />
<link rel="icon" href="icon16.png" />
<link rev="made" href="mailto:mikio@users.sourceforge.net" />
<title>Specifications of Tokyo Cabinet Version 1</title>
</head>

<body>

<h1>Fundamental Specification of Tokyo Cabinet Version 1</h1>

<div class="note">Copyright (C) 2006-2007 Mikio Hirabayashi</div>
<div class="note">Last Update: Wed, 24 Oct 2007 01:26:07 +0900</div>
<div class="navi">[<span class="void">English</span>/<a href="spex-ja.html" hreflang="ja">Japanese</a>] [<a href="index.html">HOME</a>]</div>

<hr />

<h2 id="contents">Table of Contents</h2>

<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#tcutilapi">The Utility API</a></li>
<li><a href="#tchdbapi">The Hash Database API</a></li>
<li><a href="#tcbdbapi">The B+ Tree API</a></li>
<li><a href="#license">License</a></li>
</ol>

<hr />

<h2 id="introduction">Introduction</h2>

<p>Tokyo Cabinet is a library of routines for managing a database.  The database is a simple data file containing records, each is a pair of a key and a value.  Every key and value is serial bytes with variable length.  Both binary data and character string can be used as a key and a value.  There is neither concept of data tables nor data types.  Records are organized in hash table or B+ tree.</p>

<p>As for database of hash table, each key must be unique within a database, so it is impossible to store two or more records with a key overlaps.  The following access methods are provided to the database: storing a record with a key and a value, deleting a record by a key, retrieving a record by a key.  Moreover, traversal access to every key are provided, although the order is arbitrary.  These access methods are similar to ones of DBM (or its followers: NDBM and GDBM) library defined in the UNIX standard.  Tokyo Cabinet is an alternative for DBM because of its higher performance.</p>

<p>As for database of B+ tree, records whose keys are duplicated can be stored.  Access methods of storing, deleting, and retrieving are provided as with the database of hash table.  Records are stored in order by a comparison function assigned by a user.  It is possible to access each record with the cursor in ascending or descending order.  According to this mechanism, forward matching search for strings and range search for integers are realized.  Moreover, transaction is available in database of B+ tree.</p>

<p>Tokyo Cabinet is written in the C language, and provided as API of C, Perl, Ruby, and Java.  Tokyo Cabinet is available on platforms which have API conforming to C99 and POSIX.  Tokyo Cabinet is a free software licensed under the GNU Lesser General Public License.</p>

<hr />

<h2 id="features">Features</h2>

<p>Tokyo Cabinet is the successor of QDBM and improves time and space efficiency.  This section describes the features of Tokyo Cabinet.</p>

<h3>The Dinosaur Wing of the DBM fork</h3>

<p>Tokyo Cabinet is developed as the successor of <a href="http://qdbm.sourceforge.net/">QDBM</a> on the following purposes.  They are achieved and Tokyo Cabinet replaces QDBM.</p>

<ul>
<li>improves space efficiency : smaller size of database file.</li>
<li>improves time efficiency : faster processing speed.</li>
<li>improves parallelism : higher performance in multi-thread environment.</li>
<li>improves usability : simplified API.</li>
<li>improves robustness : database file is not corrupted even under catastrophic situation.</li>
<li>supports 64-bit architecture : enormous memory space and database file are available.</li>
</ul>

<p>As with QDBM, the following three restrictions of traditional DBM: a process can handle only one database, the size of a key and a value is bounded, a database file is sparse, are cleared.  Moreover, the following three restrictions of QDBM: the size of a database file is limited to 2GB, environments with different byte orders can not share a database file, only one thread can search a database at the same time, are cleared.</p>

<p>Tokyo Cabinet runs very fast.  For example, elapsed time to store 1 million records is 1.5 seconds for hash database, and 2.2 seconds for B+ tree database.  Moreover, the size of database of Tokyo Cabinet is very small.  For example, overhead for a record is 16 bytes for hash database, and 5 bytes for B+ tree database.  Furthermore, scalability of Tokyo Cabinet is great.  The database size can be up to 8EB (9.22e18 bytes).</p>

<h3>Effective Implementation of Hash Database</h3>

<p>Tokyo Cabinet uses hash algorithm to retrieve records.  If a bucket array has sufficient number of elements, the time complexity of retrieval is `O(1)'.  That is, time required for retrieving a record is constant, regardless of the scale of a database.  It is also the same about storing and deleting.  Collision of hash values is managed by separate chaining.  Data structure of the chains is binary search tree.  Even if a bucket array has unusually scarce elements, the time complexity of retrieval is `O(log n)'.</p>

<p>Tokyo Cabinet attains improvement in retrieval by loading RAM with the whole of a bucket array.  If a bucket array is on RAM, it is possible to access a region of a target record by about one path of file operations.  A bucket array saved in a file is not read into RAM with the `read' call but directly mapped to RAM with the `mmap' call.  Therefore, preparation time on connecting to a database is very short, and two or more processes can share the same memory map.</p>

<p>If the number of elements of a bucket array is about half of records stored within a database, although it depends on characteristic of the input, the probability of collision of hash values is about 56.7% (36.8% if the same, 21.3% if twice, 11.5% if four times, 6.0% if eight times).  In such case, it is possible to retrieve a record by two or less paths of file operations.  If it is made into a performance index, in order to handle a database containing one million of records, a bucket array with half a million of elements is needed.  The size of each element is 4 bytes.  That is, if 2M bytes of RAM is available, a database containing one million records can be handled.</p>

<p>Traditional DBM provides two modes of the storing operations: `insert' and `replace'.  In the case a key overlaps an existing record, the insert mode keeps the existing value, while the replace mode transposes it to the specified value.  In addition to the two modes, Tokyo Cabinet provides `concatenate' mode.  In the mode, the specified value is concatenated at the end of the existing value and stored.  This feature is useful when adding a element to a value as an array.  Moreover, although DBM has a method to fetch out a value from a database only by reading the whole of a region of a record, Tokyo Cabinet has a method to fetch out a part of a region of a value.  When a value is treated as an array, this feature is also useful.</p>

<p>Generally speaking, while succession of updating, fragmentation of available regions occurs, and the size of a database grows rapidly.  Tokyo Cabinet deal with this problem by coalescence of dispensable regions and reuse of them, and featuring of optimization of a database.  When overwriting a record with a value whose size is greater than the existing one, it is necessary to remove the region to another position of the file.  Because the time complexity of the operation depends on the size of the region of a record, extending values successively is inefficient.  However, Tokyo Cabinet deal with this problem by alignment.  If increment can be put in padding, it is not necessary to remove the region.</p>

<h3>Useful Implementation of B+ Tree Database</h3>

<p>Although B+ tree database is slower than hash database, it features ordering access to each record.  The order can be assigned by users.  Records of B+ tree are sorted and arranged in logical pages.  Sparse index organized in B tree that is multiway balanced tree are maintained for each page.  Thus, the time complexity of retrieval and so on is `O(log n)'.  Cursor is provided to access each record in order.  The cursor can jump to a position specified by a key and can step forward or backward from the current position.  Because each page is arranged as double linked list, the time complexity of stepping cursor is `O(1)'.</p>

<p>B+ tree database is implemented, based on above hash database.  Because each page of B+ tree is stored as each record of hash database, B+ tree database inherits efficiency of storage management of hash database.  Because the header of each record is smaller and alignment of each page is adjusted according to the page size, in most cases, the size of database file is cut by half compared to one of hash database.  Although operation of many pages are required to update B+ tree, QDBM expedites the process by caching pages and reducing file operations.  In most cases, because whole of the sparse index is cached on memory, it is possible to retrieve a record by one or less path of file operations.</p>

<p>B+ tree database features transaction mechanism.  It is possible to commit a series of operations between the beginning and the end of the transaction in a lump, or to abort the transaction and perform rollback to the state before the transaction.  Two isolation levels are supported; serializable and read uncommitted.</p>

<p>Each pages of B+ tree can be stored with compressed.  Two compression method; Deflate of ZLIB and Block Sorting, are supported.  Because each record in a page has similar patterns, high efficiency of compression is expected due to the Lempel-Ziv or the BWT algorithms.  In case handling text data, the size of a database is reduced to about 25%.  If the scale of a database is large and disk I/O is the bottleneck, featuring compression makes the processing speed improved to a large extent.</p>

<h3>Simple but Various Interfaces</h3>

<p>Tokyo Cabinet provides simple API based on the object oriented design.  Every operation for database is encapsulated and published as lucid methods as `open' (connect), `close' (disconnect), `put' (insert), `out' (remove), `get' (retrieve), and so on.  Because the two of the hash and the B+ tree database APIs are very similar with each other, porting an application from one to the other is easy.</p>

<p>Tokyo Cabinet provides two modes to connect to a database: `reader' and `writer'.  A reader can perform retrieving but neither storing nor deleting.  A writer can perform all access methods.  Exclusion control between processes is performed when connecting to a database by file locking.  While a writer is connected to a database, neither readers nor writers can be connected.  While a reader is connected to a database, other readers can be connect, but writers can not.  According to this mechanism, data consistency is guaranteed with simultaneous connections in multitasking environment.</p>

<p>Functions of API of Tokyo cabinet are reentrant and available in multi-thread environment.  Discrete database object can be operated in parallel entirely.  For simultaneous operations of the same database object, read-write lock is used for exclusion control.  That is, while a writing thread is operating the database, other reading threads and writing threads are blocked.  However, while a reading thread is operating the database, reading threads are not blocked.</p>

<p>The utility API is also provided.  Such fundamental data structure as list and map are included.  And, some useful features; memory pool, string processing, encoding, are also included.</p>

<p>Three kinds of API; the utility API, the hash database API, and the B+ tree database API, are provided for the C language.  Command line interfaces are also provided corresponding to each API.  They are usuful for prototyping, test, and debugging.  Except for C, Tokyo Cabinet provides APIs for Perl, Ruby, and Java.  The Perl API has methods calling the hash database API and the B+ tree database API with XS language.  The Java API has native methods calling the hash database API and the B+ tree API with Java Native Interface.  The Ruby API has methods calling the hash database API and the B+ tree database API as modules of Ruby.  APIs for other languages will hopefully be provided by third party.</p>

<hr />

<h2 id="installation">Installation</h2>

<p>This section describes how to install Tokyo Cabinet with the source package.  As for a binary package, see its installation manual.</p>

<h3>Preparation</h3>

<p>Tokyo Cabinet is available on UNIX-like systems.  At least, the following environments are supported.</p>

<ul>
<li>Linux 2.4 and later (IA32/IA64/AMD64)</li>
</ul>

<p><code>gcc</code> 3.1 or later and <code>make</code> are required to install Tokyo Cabinet with the source package.  They are installed by default on Linux, FreeBSD and so on.</p>

<p>As Tokyo Cabinet depends on the following libraries, install them beforehand.</p>

<ul>
<li><a href="http://www.gzip.org/zlib/">zlib</a> : for loss-less data compression.  1.2.1 or later is suggested.</li>
</ul>

<h3>Installation</h3>

<p>When an archive file of Tokyo Cabinet is extracted, change the current working directory to the generated directory and perform installation.</p>

<p>Run the configuration script.</p>

<pre>./configure
</pre>

<p>Build programs.</p>

<pre>make
</pre>

<p>Perform self-diagnostic test.</p>

<pre>make check
</pre>

<p>Install programs.  This operation must be carried out by the <code>root</code> user.</p>

<pre>make install
</pre>

<h3>Result</h3>

<p>When a series of work finishes, the following files will be installed.</p>

<pre>/usr/local/include/tcutil.h
/usr/local/include/tchdb.h
/usr/local/include/tcbdb.h
/usr/local/lib/libtokyocabinet.a
/usr/local/lib/libtokyocabinet.so.1.11.0
/usr/local/lib/libtokyocabinet.so.1
/usr/local/lib/libtokyocabinet.so
/usr/local/lib/pkgconfig/tokyocabinet.pc
/usr/local/bin/tcucodec
/usr/local/bin/tcutest
/usr/local/bin/tchmgr
/usr/local/bin/tchtest
/usr/local/bin/tchmttest
/usr/local/bin/tcbmgr
/usr/local/bin/tcbtest
/usr/local/bin/tcbmttest
/usr/local/share/tokyocabinet/...
/usr/local/man/man1/...
/usr/local/man/man3/...
</pre>

<h3>Options of Configure</h3>

<p>The following options can be specified with `<code>./configure</code>'.</p>

<ul class="options">
<li><code>--enable-debug</code> : build for debugging.  Enable debugging symbols, do not perform optimization, and perform static linking.</li>
<li><code>--enable-devel</code> : build for development.  Enable debugging symbols, perform optimization, and perform dynamic linking.</li>
<li><code>--enable-fastest</code> : build for fastest run.</li>
<li><code>--enable-swab</code> : build for swapping byte-orders.</li>
<li><code>--disable-zlib</code> : build without ZLIB compression.</li>
<li><code>--disable-pthread</code> : build without POSIX thread support.</li>
<li><code>--disable-shared</code> :  avoid to build shared libraries.</li>
</ul>

<p>`<code>--prefix</code>' and other options are also available as with usual UNIX software packages.  If you want to install Tokyo Cabinet under `<code>/usr</code>' not `<code>/usr/local</code>', specify `<code>--prefix=/usr</code>'.  As well, the library search path does not include `<code>/usr/local/lib</code>', it is necessary to set the environment variable `<code>LD_LIBRARY_PATH</code>' to include `<code>/usr/local/lib</code>' before running applications of Tokyo Cabinet.</p>

<h3>How to Use the Library</h3>

<p>Tokyo Cabinet provides API of the C language and it is available by programs conforming to the C89 (ANSI C) standard or the C99 standard.  As the header files of Tokyo Cabinet are provided as `<code>tcutil.h</code>', `<code>tchdb.h</code>', and `<code>tcbdb.h</code>', applications should include one or more of them accordingly to use the API.  As the library is provided as `<code>libtokyocabinet.a</code>' and `<code>libtokyocabinet.so</code>' and they depends `<code>libz.so</code>', `<code>libpthread.so</code>', `<code>libm.so</code>', and `<code>libc.so</code>', linker options `<code>-ltokyocabinet</code>', `<code>-lz</code>', `<code>-lpthread</code>', `<code>-lm</code>', and `<code>-lc</code>' are required for build command.  A typical build command is the following.</p>

<pre>gcc -I/usr/local/include tc_example.c -o tc_example \
  -L/usr/local/lib -ltokyocabinet -lz -lm -lc
</pre>

<p>You can also use Tokyo Cabinet in programs written in C++.  Because each header is wrapped in C linkage (`<code>extern "C"</code>' block), you can simply include them into your C++ programs.</p>

<hr />

<h2 id="tcutilapi">The Utility API</h2>

<p>The utility API is a set of routines to handle records on memory easily.  Especially, extensible string, array list, and hash map are useful.  See `<code>tcutil.h</code>' for entire specification.</p>

<h3>Description</h3>

<p>To use the utility API, include `<code>tcutil.h</code>' and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCXSTR</code>' are used for extensible string.  An extensible string object is created with the function `<code>tcxstrnew</code>' and is deleted with the function `<code>tcxstrdel</code>'.  Objects whose type is pointer to `<code>TCLIST</code>' are used for array list.  A list object is created with the function `<code>tclistnew</code>' and is deleted with the function `<code>tclistdel</code>'.  Objects whose type is pointer to `<code>TCMAP</code>' are used for hash map.  A map object is created with the function `<code>tcmapnew</code>' and is deleted with the function `<code>tcmapdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<h3>API of Basic Utilities</h3>

<p>The constant `tcversion' is the string containing the version information.</p>

<dl class="api">
<dt><code>extern const char *tcversion;</code></dt>
</dl>

<p>The variable `tcfatalfunc' is the pointer to the call back function for handling a fatal error.</p>

<dl class="api">
<dt><code>extern void (*tcfatalfunc)(const char *);</code></dt>
<dd>The argument specifies the error message.  The initial value of this variable is `NULL'.</dd>
<dd>If the value is `NULL', the default function is called when a fatal error occurs.  A fatal error occurs when memory allocation is failed.</dd>
</dl>

<p>The function `tcmalloc' is used in order to allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmalloc(size_t <var>size</var>);</code></dt>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tccalloc' is used in order to allocate a nullified region on memory.</p>

<dl class="api">
<dt><code>void *tccalloc(size_t <var>nmemb</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated nullified region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `calloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcrealloc' is used in order to re-allocate a region on memory.</p>

<dl class="api">
<dt><code>void *tcrealloc(void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the re-allocated region.</dd>
<dd>This function handles failure of memory allocation implicitly.  Because the region of the return value is allocated with the `realloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmemdup' is used in order to duplicate a region on memory.</p>

<dl class="api">
<dt><code>void *tcmemdup(const void *<var>ptr</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the pointer to the allocated region of the duplicate.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcstrdup' is used in order to duplicate a string on memory.</p>

<dl class="api">
<dt><code>char *tcstrdup(const void *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the allocated string equivalent to the specified string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcfree' is used in order to free a region on memory.</p>

<dl class="api">
<dt><code>void tcfree(void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.  If it is `NULL', this function has no effect.</dd>
<dd>Although this function is just a wrapper of `free' call, this is useful in applications using another package of the `malloc' series.</dd>
</dl>

<h3>API of Extensible String</h3>

<p>The function `tcxstrnew' is used in order to create an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew(void);</code></dt>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrnew2' is used in order to create an extensible string object from a character string.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew2(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of the initial content.</dd>
<dd>The return value is the new extensible string object containing the specified string.</dd>
</dl>

<p>The function `tcxstrnew3' is used in order to create an extensible string object with the initial allocation size.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrnew3(int <var>asiz</var>);</code></dt>
<dd>`<var>asiz</var>' specifies the initial allocation size.</dd>
<dd>The return value is the new extensible string object.</dd>
</dl>

<p>The function `tcxstrdup' is used in order to copy an extensible string object.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrdup(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the new extensible string object equivalent to the specified object.</dd>
</dl>

<p>The function `tcxstrdel' is used in order to delete an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrdel(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcxstrcat' is used in order to concatenate a region to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat(TCXSTR *<var>xstr</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region to be appended.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tcxstrcat2' is used in order to concatenate a character string to the end of an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrcat2(TCXSTR *<var>xstr</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>str</var>' specifies the string to be appended.</dd>
</dl>

<p>The function `tcxstrptr' is used in order to get the pointer of the region of an extensible string object.</p>

<dl class="api">
<dt><code>const void *tcxstrptr(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer of the region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcxstrsize' is used in order to get the size of the region of an extensible string object.</p>

<dl class="api">
<dt><code>int tcxstrsize(const TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the size of the region of the object.</dd>
</dl>

<p>The function `tcxstrclear' is used in order to clear an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrclear(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The internal buffer of the object is cleared and the size is set zero.</dd>
</dl>

<p>The function `tcxstrtomalloc' is used in order to convert an extensible string object into a usual allocated region.</p>

<dl class="api">
<dt><code>void *tcxstrtomalloc(TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>The return value is the pointer to the allocated region of the object.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  Because the region of the original object is deleted, it should not be deleted again.</dd>
</dl>

<p>The function `tcxstrfrommalloc' is used in order to create an extensible string object from an allocated region.</p>

<dl class="api">
<dt><code>TCXSTR *tcxstrfrommalloc(void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region allocated with `malloc' call.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the new extensible string object wrapping the specified region.</dd>
<dd>Note that the specified region is released when the object is deleted.</dd>
</dl>

<p>The function `tcxstrprintf' is used in order to perform formatted output into an extensible string object.</p>

<dl class="api">
<dt><code>void tcxstrprintf(TCXSTR *<var>xstr</var>, const char *<var>format</var>, ...);</code></dt>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
</dl>

<p>The function `tcsprintf' is used in order to allocate a formatted string on memory.</p>

<dl class="api">
<dt><code>char *tcsprintf(const char *<var>format</var>, ...);</code></dt>
<dd>`<var>format</var>' specifies the printf-like format string.  The conversion character `%' can be used with such flag characters as `s', `d', `o', `u', `x', `X', `c', `e', `E', `f', `g', `G', `@', `?', `%'.  `@' works as with `s' but escapes meta characters of XML.  `?' works as with `s' but escapes meta characters of URL.  The other conversion character work as with each original.</dd>
<dd>The other arguments are used according to the format string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<h3>API of Array List</h3>

<p>The function `tclistnew' is used in order to create a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew(void);</code></dt>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistnew2' is used in order to create a list object with expecting the number of elements.</p>

<dl class="api">
<dt><code>TCLIST *tclistnew2(int <var>anum</var>);</code></dt>
<dd>`<var>anum</var>' specifies the number of elements expected to be stored in the list.</dd>
<dd>The return value is the new list object.</dd>
</dl>

<p>The function `tclistdup' is used in order to copy a list object.</p>

<dl class="api">
<dt><code>TCLIST *tclistdup(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the new list object equivalent to the specified object.</dd>
</dl>

<p>The function `tclistdel' is used in order to delete a list object.</p>

<dl class="api">
<dt><code>void tclistdel(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tclistnum' is used in order to get the number of elements of a list object.</p>

<dl class="api">
<dt><code>int tclistnum(const TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the number of elements of the list.</dd>
</dl>

<p>The function `tclistval' is used in order to get the pointer to the region of an element of a list object.</p>

<dl class="api">
<dt><code>const void *tclistval(const TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistval2' is used in order to get the string of an element of a list object.</p>

<dl class="api">
<dt><code>const char *tclistval2(const TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element.</dd>
<dd>The return value is the string of the value.</dd>
<dd>If `index' is equal to or more than the number of elements, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpush' is used in order to add an element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistpush2' is used in order to add a string element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpush2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistpushmalloc' is used in order to add an allocated element at the end of a list object.</p>

<dl class="api">
<dt><code>void tclistpushmalloc(TCLIST *<var>list</var>, void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region allocated with `malloc' call.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>Note that the specified region is released when the object is deleted.</dd>
</dl>

<p>The function `tclistpop' is used in order to remove an element of the end of a list object.</p>

<dl class="api">
<dt><code>void *tclistpop(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistpop2' is used in order to remove a string element of the end of a list object.</p>

<dl class="api">
<dt><code>char *tclistpop2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistunshift' is used in order to add an element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift(TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
</dl>

<p>The function `tclistunshift2' is used in order to add a string element at the top of a list object.</p>

<dl class="api">
<dt><code>void tclistunshift2(TCLIST *<var>list</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
</dl>

<p>The function `tclistshift' is used in order to remove an element of the top of a list object.</p>

<dl class="api">
<dt><code>void *tclistshift(TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistshift2' is used in order to remove a string element of the top of a list object.</p>

<dl class="api">
<dt><code>char *tclistshift2(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If the list is empty, the return value is `NULL'.</dd>
</dl>

<p>The function `tclistinsert' is used in order to add an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new element.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistinsert2' is used in order to add a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistinsert2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the new element.</dd>
<dd>`<var>str</var>' specifies the string of the new element.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistremove' is used in order to remove an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void *tclistremove(TCLIST *<var>list</var>, int <var>index</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the removed element.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistremove2' is used in order to remove a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>char *tclistremove2(TCLIST *<var>list</var>, int <var>index</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be removed.</dd>
<dd>The return value is the string of the removed element.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  If `index' is equal to or more than the number of elements, no element is removed and the return value is `NULL'.</dd>
</dl>

<p>The function `tclistover' is used in order to overwrite an element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover(TCLIST *<var>list</var>, int <var>index</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the new content.</dd>
<dd>`<var>size</var>' specifies the size of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistover2' is used in order to overwrite a string element at the specified location of a list object.</p>

<dl class="api">
<dt><code>void tclistover2(TCLIST *<var>list</var>, int <var>index</var>, const char *<var>str</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>index</var>' specifies the index of the element to be overwritten.</dd>
<dd>`<var>str</var>' specifies the string of the new content.</dd>
<dd>If `index' is equal to or more than the number of elements, this function has no effect.</dd>
</dl>

<p>The function `tclistsort' is used in order to sort elements of a list object in lexical order.</p>

<dl class="api">
<dt><code>void tclistsort(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistsortci' is used in order to sort elements of a list object in case-insensitive lexical order.</p>

<dl class="api">
<dt><code>void tclistsortci(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
</dl>

<p>The function `tclistlsearch' is used in order to search a list object for an element using liner search.</p>

<dl class="api">
<dt><code>int tclistlsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, the former returns.</dd>
</dl>

<p>The function `tclistbsearch' is used in order to search a list object for an element using binary search.</p>

<dl class="api">
<dt><code>int tclistbsearch(const TCLIST *<var>list</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.  It should be sorted in lexical order.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the index of a corresponding element or -1 if there is no corresponding element.</dd>
<dd>If two or more elements correspond, which returns is not defined.</dd>
</dl>

<p>The function `tclistclear' is used in order to clear a list object.</p>

<dl class="api">
<dt><code>void tclistclear(TCLIST *<var>list</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>All elements are removed.</dd>
</dl>

<p>The function `tclistdump' is used in order to serialize a list object into a byte array.</p>

<dl class="api">
<dt><code>void *tclistdump(const TCLIST *<var>list</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tclistload' is used in order to create a list object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCLIST *tclistload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new list object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<h3>API of Hash Map</h3>

<p>The function `tcmapnew' is used in order to create a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew(void);</code></dt>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapnew2' is used in order to create a map object with specifying the number of the buckets.</p>

<dl class="api">
<dt><code>TCMAP *tcmapnew2(int <var>bnum</var>);</code></dt>
<dd>`<var>bnum</var>' specifies the number of the buckets.</dd>
<dd>The return value is the new map object.</dd>
</dl>

<p>The function `tcmapdup' is used in order to copy a map object.</p>

<dl class="api">
<dt><code>TCMAP *tcmapdup(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new map object equivalent to the specified object.</dd>
</dl>

<p>The function `tcmapdel' is used in order to delete a map object.</p>

<dl class="api">
<dt><code>void tcmapdel(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the list object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmapput' is used in order to store a record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmapput2' is used in order to store a string record into a map object.</p>

<dl class="api">
<dt><code>void tcmapput2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>over</var>' specifies whether the value of the duplicated record is overwritten or not.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcmapputkeep' is used in order to store a new record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmapputkeep2' is used in order to store a new string record into a map object.</p>

<dl class="api">
<dt><code>bool tcmapputkeep2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcmapputcat' is used in order to concatenate a value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapputcat2' is used in order to concatenate a string value at the end of the value of the existing record in a map object.</p>

<dl class="api">
<dt><code>void tcmapputcat2(TCMAP *<var>map</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcmapout' is used in order to remove a record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapout2' is used in order to remove a string record of a map object.</p>

<dl class="api">
<dt><code>bool tcmapout2(TCMAP *<var>map</var>, const void *kstr);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapget' is used in order to retrieve a record in a map object.</p>

<dl class="api">
<dt><code>const void *tcmapget(const TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapget2' is used in order to retrieve a string record in a map object.</p>

<dl class="api">
<dt><code>const char *tcmapget2(const TCMAP *<var>map</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
</dl>

<p>The function `tcmapmove' is used in order to move a record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove(TCMAP *<var>map</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of a key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>head</var>' specifies the destination which is head if it is true or tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapmove2' is used in order to move a string record to the edge of a map object.</p>

<dl class="api">
<dt><code>bool tcmapmove2(TCMAP *<var>map</var>, const char *<var>kstr</var>, bool <var>head</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>kstr</var>' specifies the string of a key.</dd>
<dd>`<var>head</var>' specifies the destination which is head if it is true or tail if else.</dd>
<dd>If successful, the return value is true.  False is returned when no record corresponds to the specified key.</dd>
</dl>

<p>The function `tcmapiterinit' is used in order to initialize the iterator of a map object.</p>

<dl class="api">
<dt><code>void tcmapiterinit(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The iterator is used in order to access the key of every record stored in the map object.</dd>
</dl>

<p>The function `tcmapiternext' is used in order to get the next key of the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiternext(TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiternext2' is used in order to get the next key string of the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiternext2(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record can be fetched from the iterator.</dd>
<dd>The order of iteration is assured to be the same as the stored order.</dd>
</dl>

<p>The function `tcmapiterval' is used in order to get the value bound to the key fetched from the iterator of a map object.</p>

<dl class="api">
<dt><code>const void *tcmapiterval(const void *<var>kbuf</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the iteration key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the value of the corresponding record.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<p>The function `tcmapiterval2' is used in order to get the value string bound to the key fetched from the iterator of a map object.</p>

<dl class="api">
<dt><code>const char *tcmapiterval2(const char *<var>kstr</var>);</code></dt>
<dd>`<var>kstr</var>' specifies the string of the iteration key.</dd>
<dd>The return value is the pointer to the region of the value of the corresponding record.</dd>
</dl>

<p>The function `tcmaprnum' is used in order to get the number of records stored in a map object.</p>

<dl class="api">
<dt><code>int tcmaprnum(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the number of the records stored in the map object.</dd>
</dl>

<p>The function `tcmapkeys' is used in order to create a list object containing all keys in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapkeys(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all keys in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapvals' is used in order to create a list object containing all values in a map object.</p>

<dl class="api">
<dt><code>TCLIST *tcmapvals(const TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>The return value is the new list object containing all values in the map object.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmapclear' is used in order to clear a list object.</p>

<dl class="api">
<dt><code>void tcmapclear(TCMAP *<var>map</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>All records are removed.</dd>
</dl>

<p>The function `tcmapdump' is used in order to serialize map list object into a byte array.</p>

<dl class="api">
<dt><code>void *tcmapdump(const TCMAP *<var>map</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result serial region.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmapload' is used in order to create a map object from a serialized byte array.</p>

<dl class="api">
<dt><code>TCMAP *tcmapload(const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is a new map object.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcmaploadone' is used in order to extract a map record from a serialized byte array.</p>

<dl class="api">
<dt><code>void *tcmaploadone(const void *<var>ptr</var>, int <var>size</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region of serialized byte array.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned when no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.</dd>
</dl>

<h3>API of Memory Pool</h3>

<p>The function `tcmpoolnew' is used in order to create a memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolnew(void);</code></dt>
<dd>The return value is the new memory pool object.</dd>
</dl>

<p>The function `tcmpooldel' is used in order to delete a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpooldel(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcmpoolput' is used in order to relegate an arbitrary object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolput(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>, void (*<var>del</var>)(void *));</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the object to be relegated.</dd>
<dd>`<var>del</var>' specifies the pointer to the function to delete the object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputptr' is used in order to relegate an allocated region to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputptr(TCMPOOL *<var>mpool</var>, void *<var>ptr</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region to be relegated.</dd>
<dd>This function assures that the specified region is released when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputxstr' is used in order to relegate an extensible string object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputxstr(TCMPOOL *<var>mpool</var>, TCXSTR *<var>xstr</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>xstr</var>' specifies the extensible string object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputlist' is used in order to relegate a list object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputlist(TCMPOOL *<var>mpool</var>, TCLIST *<var>list</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>list</var>' specifies the list object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolputmap' is used in order to relegate a map object to a memory pool object.</p>

<dl class="api">
<dt><code>void tcmpoolputmap(TCMPOOL *<var>mpool</var>, TCMAP *<var>map</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>`<var>map</var>' specifies the map object.</dd>
<dd>This function assures that the specified object is deleted when the memory pool object is deleted.</dd>
</dl>

<p>The function `tcmpoolmalloc' is used in order to allocate a region relegated to a memory pool object.</p>

<dl class="api">
<dt><code>void *tcmpoolmalloc(TCMPOOL *<var>mpool</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>mpool</var>' specifies the memory pool object.</dd>
<dd>The return value is the pointer to the allocated region under the memory pool.</dd>
</dl>

<p>The function `tcmpoolxstrnew' is used in order to create an extensible string object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCXSTR *tcmpoolxstrnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new extensible string object under the memory pool.</dd>
</dl>

<p>The function `tcmpoollistnew' is used in order to create a list object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCLIST *tcmpoollistnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new list object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolmapnew' is used in order to create a map object relegated to a memory pool object.</p>

<dl class="api">
<dt><code>TCMAP *tcmpoolmapnew(TCMPOOL *<var>mpool</var>);</code></dt>
<dd>The return value is the new map object under the memory pool.</dd>
</dl>

<p>The function `tcmpoolglobal' is used in order to get the global memory pool object.</p>

<dl class="api">
<dt><code>TCMPOOL *tcmpoolglobal(void);</code></dt>
<dd>The return value is the global memory pool object.</dd>
<dd>The global memory pool object is a singleton and assured to be deleted when the process is terminating normally.</dd>
</dl>

<h3>API of Miscellaneous Utilities</h3>

<p>The function `tclmax' is used in order to get the larger value of two integers.</p>

<dl class="api">
<dt><code>long tclmax(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the larger value of the two.</dd>
</dl>

<p>The function `tclmin' is used in order to get the lesser value of two integers.</p>

<dl class="api">
<dt><code>long tclmin(long <var>a</var>, long <var>b</var>);</code></dt>
<dd>`<var>a</var>' specifies an integer.</dd>
<dd>`<var>b</var>' specifies the other integer.</dd>
<dd>The return value is the lesser value of the two.</dd>
</dl>

<p>The function `tcstricmp' is used in order to compare two strings with case insensitive evaluation.</p>

<dl class="api">
<dt><code>int tcstricmp(const char *<var>astr</var>, const char *<var>bstr</var>);</code></dt>
<dd>`<var>astr</var>' specifies a string.</dd>
<dd>`<var>bstr</var>' specifies of the other string.</dd>
<dd>The return value is positive if the former is big, negative if the latter is big, 0 if both are equivalent.</dd>
</dl>

<p>The function `tcstrfwm' is used in order to check whether a string begins with a key.</p>

<dl class="api">
<dt><code>bool tcstrfwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrifwm' is used in order to check whether a string begins with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstrifwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the forward matching key string.</dd>
<dd>The return value is true if the target string begins with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrbwm' is used in order to check whether a string ends with a key.</p>

<dl class="api">
<dt><code>bool tcstrbwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstribwm' is used in order to check whether a string ends with a key with case insensitive evaluation.</p>

<dl class="api">
<dt><code>bool tcstribwm(const char *<var>str</var>, const char *<var>key</var>);</code></dt>
<dd>`<var>str</var>' specifies the target string.</dd>
<dd>`<var>key</var>' specifies the backward matching key string.</dd>
<dd>The return value is true if the target string ends with the key, else, it is false.</dd>
</dl>

<p>The function `tcstrtoupper' is used in order to convert the letters of a string into upper case.</p>

<dl class="api">
<dt><code>char *tcstrtoupper(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtolower' is used in order to convert the letters of a string into lower case.</p>

<dl class="api">
<dt><code>char *tcstrtolower(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrtrim' is used in order to cut space characters at head or tail of a string.</p>

<dl class="api">
<dt><code>char *tcstrtrim(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsqzspc' is used in order to squeeze space characters in a string and trim it.</p>

<dl class="api">
<dt><code>char *tcstrsqzspc(char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsubchr' is used in order to substitute characters in a string.</p>

<dl class="api">
<dt><code>char *tcstrsubchr(char *<var>str</var>, const char *<var>rstr</var>, const char *<var>sstr</var>);</code></dt>
<dd>`<var>str</var>' specifies the string to be converted.</dd>
<dd>`<var>rstr</var>' specifies the string containing characters to be replaced.</dd>
<dd>`<var>sstr</var>' specifies the string containing characters to be substituted.</dd>
<dd>If the substitute string is shorter then the replacement string, corresponding characters are removed.</dd>
</dl>

<p>The function `tcstrcntutf' is used in order to count the number of characters in a string of UTF-8.</p>

<dl class="api">
<dt><code>int tcstrcntutf(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>The return value is the number of characters in the string.</dd>
</dl>

<p>The function `tcstrcututf' is used in order to cut a string of UTF-8 at the specified number of characters.</p>

<dl class="api">
<dt><code>char *tcstrcututf(char *<var>str</var>, int <var>num</var>);</code></dt>
<dd>`<var>str</var>' specifies the string of UTF-8.</dd>
<dd>`<var>num</var>' specifies the number of characters to be kept.</dd>
<dd>The return value is the string itself.</dd>
</dl>

<p>The function `tcstrsplit' is used in order to create a list object by splitting a string.</p>

<dl class="api">
<dt><code>TCLIST *tcstrsplit(const char *<var>str</var>, const char *<var>delim</var>);</code></dt>
<dd>`<var>str</var>' specifies the source string.</dd>
<dd>`<var>delim</var>' specifies a string containing delimiting characters.</dd>
<dd>The return value is a list object of the split elements.</dd>
<dd>If two delimiters are successive, it is assumed that an empty element is between the two.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tctime' is used in order to get the time of day in milliseconds.</p>

<dl class="api">
<dt><code>double tctime(void);</code></dt>
<dd>The return value is the time of day in milliseconds.</dd>
</dl>

<h3>API of Filesystem Utilities</h3>

<p>The function `tcreadfile' is used in order to read whole data of a file.</p>

<dl class="api">
<dt><code>void *tcreadfile(const char *<var>path</var>, int <var>limit</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>`<var>limit</var>' specifies the limiting size of reading data.  If it is not more than 0, the limitation is not specified.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.  If it is `NULL', it is not used.</dd>
<dd>The return value is the pointer to the allocated region of the read data, or `NULL' if the file could not be opened.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when when is no longer in use.</dd>
</dl>

<p>The function `tcreadfilelines' is used in order to read every line of a file.</p>

<dl class="api">
<dt><code>TCLIST *tcreadfilelines(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard input is specified.</dd>
<dd>The return value is a list object of every lines if successful, else it is `NULL'.</dd>
<dd>Line separators are cut out.  Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcwritefile' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwritefile(const char *<var>path</var>, const void *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the file.  If it is `NULL', the standard output is specified.</dd>
<dd>`<var>ptr</var>' specifies the pointer to the data region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcreaddir' is used in order to read names of files in a directory.</p>

<dl class="api">
<dt><code>TCLIST *tcreaddir(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the directory.</dd>
<dd>The return value is a list object of names if successful, else it is `NULL'.</dd>
<dd>Links to the directory itself and to the parent directory are ignored.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcremovelink' is used in order to remove a file or a directory and its sub ones recursively.</p>

<dl class="api">
<dt><code>bool tcremovelink(const char *<var>path</var>);</code></dt>
<dd>`<var>path</var>' specifies the path of the link.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the link does not exist or the permission is denied.</dd>
</dl>

<p>The function `tcwrite' is used in order to write data into a file.</p>

<dl class="api">
<dt><code>bool tcwrite(int <var>fd</var>, const void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to be written.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tcread' is used in order to read data from a file.</p>

<dl class="api">
<dt><code>bool tcread(int <var>fd</var>, void *<var>buf</var>, size_t <var>size</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>buf</var>' specifies the buffer to store into.</dd>
<dd>`<var>size</var>' specifies the size of the buffer.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<p>The function `tclock' is used in order to lock a file.</p>

<dl class="api">
<dt><code>bool tclock(int <var>fd</var>, bool <var>ex</var>, bool <var>nb</var>);</code></dt>
<dd>`<var>fd</var>' specifies the file descriptor.</dd>
<dd>`<var>ex</var>' specifies whether an exclusive lock or a shared lock is performed.</dd>
<dd>`<var>nb</var>' specifies whether to request with non-blocking.</dd>
<dd>The return value is true if successful, else, it is false.</dd>
</dl>

<h3>API of Encoding Utilities</h3>

<p>The function `tcurlencode' is used in order to encode a serial object with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurlencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcurldecode' is used in order to decode a string encoded with URL encoding.</p>

<dl class="api">
<dt><code>char *tcurldecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcurlbreak' is used in order to break up a URL into elements.</p>

<dl class="api">
<dt><code>TCMAP *tcurlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the URL string.</dd>
<dd>The return value is the map handle whose keys are the name of elements.  The key "self" specifies the URL itself.  The key "scheme" specifies the scheme.  The key "host" specifies the host of the server.  The key "port" specifies the port number of the server.  The key "authority" specifies the authority information.  The key "path" specifies the path of the resource.  The key "file" specifies the file name without the directory section.  The key "query" specifies the query string.  The key "fragment" specifies the fragment string.</dd>
<dd>Supported schema are HTTP, HTTPS, FTP, and FILE.  Absolute URL and relative URL are supported.  Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcurlresolve' is used in order to resolve a relative URL with an absolute URL.</p>

<dl class="api">
<dt><code>char *tcurlresolve(const char *<var>base</var>, const char *<var>target</var>);</code></dt>
<dd>`<var>base</var>' specifies the absolute URL of the base location.</dd>
<dd>`<var>target</var>' specifies the URL to be resolved.</dd>
<dd>The return value is the resolved URL.  If the target URL is relative, a new URL of relative location from the base location is returned.  Else, a copy of the target URL is returned.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbaseencode' is used in order to encode a serial object with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbaseencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcbasedecode' is used in order to decode a string encoded with Base64 encoding.</p>

<dl class="api">
<dt><code>char *tcbasedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcquoteencode' is used in order to encode a serial object with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquoteencode(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call if when is no longer in use.</dd>
</dl>

<p>The function `tcquotedecode' is used in order to decode a string encoded with Quoted-printable encoding.</p>

<dl class="api">
<dt><code>char *tcquotedecode(const char *<var>str</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>The return value is the pointer to the region of the result.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimeencode' is used in order to encode a string with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimeencode(const char *<var>str</var>, const char *<var>encname</var>, bool <var>base</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>`<var>encname</var>' specifies the string of the name of the character encoding.</dd>
<dd>`<var>base</var>' specifies whether to use Base64 encoding.  If it is false, Quoted-printable is used.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcmimedecode' is used in order to decode a string encoded with MIME encoding.</p>

<dl class="api">
<dt><code>char *tcmimedecode(const char *<var>str</var>, char *<var>enp</var>);</code></dt>
<dd>`<var>str</var>' specifies the encoded string.</dd>
<dd>`<var>enp</var>' specifies the pointer to the region into which the name of encoding is written.  If it is `NULL', it is not used.  The size of the buffer should be equal to or more than 32 bytes.</dd>
<dd>The return value is the result string.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackencode' is used in order to compress a serial object with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcpackdecode' is used in order to decompress a serial object compressed with Packbits encoding.</p>

<dl class="api">
<dt><code>char *tcpackdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsencode' is used in order to compress a serial object with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbsdecode' is used in order to decompress a serial object compressed with TCBS encoding.</p>

<dl class="api">
<dt><code>char *tcbsdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcdeflate' is used in order to compress a serial object with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcdeflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcinflate' is used in order to decompress a serial object compressed with Deflate encoding.</p>

<dl class="api">
<dt><code>char *tcinflate(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipencode' is used in order to compress a serial object with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipencode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgzipdecode' is used in order to decompress a serial object compressed with GZIP encoding.</p>

<dl class="api">
<dt><code>char *tcgzipdecode(const char *<var>ptr</var>, int <var>size</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>`<var>sp</var>' specifies the pointer to a variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the result object, else, it is `NULL'.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcgetcrc' is used in order to get the CRC32 checksum of a serial object.</p>

<dl class="api">
<dt><code>unsigned int tcgetcrc(const char *<var>ptr</var>, int <var>size</var>);</code></dt>
<dd>`<var>ptr</var>' specifies the pointer to the region.</dd>
<dd>`<var>size</var>' specifies the size of the region.</dd>
<dd>The return value is the CRC32 checksum of the object.</dd>
</dl>

<p>The function `tcxmlescape' is used in order to escape meta characters in a string with the entity references of XML.</p>

<dl class="api">
<dt><code>char *tcxmlescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the pointer to the escaped string.</dd>
<dd>This function escapes only `&amp;', `&lt;', `&gt;', and `&quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlunescape' is used in order to unescape entity references in a string of XML.</p>

<dl class="api">
<dt><code>char *tcxmlunescape(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the string.</dd>
<dd>The return value is the unescaped string.</dd>
<dd>This function restores only `&amp;amp;', `&amp;lt;', `&amp;gt;', and `&amp;quot;'.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcxmlbreak' is used in order to split an XML string into tags and text sections.</p>

<dl class="api">
<dt><code>TCLIST *tcxmlbreak(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the XML string.</dd>
<dd>The return value is the list object whose elements are strings of tags or text sections.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.  Because this function does not check validation, it can handle also HTML and SGML.</dd>
</dl>

<p>The function `tcxmlattrs' is used in order to get the map of attributes of an XML tag.</p>

<dl class="api">
<dt><code>TCMAP *tcxmlattrs(const char *<var>str</var>);</code></dt>
<dd>`<var>str</var>' specifies the pointer to the region of a tag string.</dd>
<dd>The return value is the map object containing attribute names and their values which are unescaped.  You can get the name of the tag with the key of an empty string.</dd>
<dd>Because the object of the return value is created with the function `tcmapnew', it should be deleted with the function `tcmapdel' when it is no longer in use.</dd>
</dl>

<h3>Example</h3>

<p>The following code is an example using extensible string, array list, and hash map.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

  { /* example to use an extensible string object */
    TCXSTR *xstr;
    /* create the object */
    xstr = tcxstrnew();
    /* concatenate strings */
    tcxstrcat2(xstr, "hop");
    tcxstrcat2(xstr, "step");
    tcxstrcat2(xstr, "jump");
    /* print the size and the content */
    printf("%d:%s\n", tcxstrsize(xstr), (char *)tcxstrptr(xstr));
    /* delete the object */
    tcxstrdel(xstr);
  }

  { /* example to use a list object */
    TCLIST *list;
    int i;
    /* create the object */
    list = tclistnew();
    /* add strings to the tail */
    tclistpush2(list, "hop");
    tclistpush2(list, "step");
    tclistpush2(list, "jump");
    /* print all elements */
    for(i = 0; i &lt; tclistnum(list); i++){
      printf("%d:%s\n", i, tclistval2(list, i));
    }
    /* delete the object */
    tclistdel(list);
  }

  { /* example to use a map object */
    TCMAP *map;
    const char *key;
    /* create the object */
    map = tcmapnew();
    /* add records */
    tcmapput2(map, "foo", "hop");
    tcmapput2(map, "bar", "step");
    tcmapput2(map, "baz", "jump");
    /* print all records */
    tcmapiterinit(map);
    while((key = tcmapiternext2(map)) != NULL){
      printf("%s:%s\n", key, tcmapget2(map, key));
    }
    /* delete the object */
    tcmapdel(map);
  }

  return 0;
}
</pre>

<h3>CLI</h3>

<p>To use the utility API easily, the commands `<code>tcutest</code>' and `<code>tcucodec</code>' are provided.</p>

<p>The command `<code>tcutest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>rnum</var>' specifies the number of iterations.  `<var>anum</var>' specifies the initial number of elements of array.  `<var>bnum</var>' specifies the number of buckets.</p>

<dl class="api">
<dt><code>tcutest xstr <var>rnum</var></code></dt>
<dd>Perform test of extensible string.</dd>
<dt><code>tcutest list <var>rnum</var> [<var>anum</var>]</code></dt>
<dd>Perform test of array list.</dd>
<dt><code>tcutest map <var>rnum</var> [<var>bnum</var>]</code></dt>
<dd>Perform test of hash map.</dd>
<dt><code>tcutest misc <var>rnum</var></code></dt>
<dd>Perform test of miscellaneous routines.</dd>
<dt><code>tcutest wicked <var>rnum</var></code></dt>
<dd>Perform updating operations of list and map selected at random.</dd>
</dl>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcucodec</code>' is a tool to use encoding and decoding features.  This command is used in the following format.  `<var>file</var>' specifies a input file.  If it is omitted, the standard input is read.</p>

<dl class="api">
<dt><code>tcucodec url [-d] [-br] [-rs <var>base</var>] [<var>file</var>]</code></dt>
<dd>Perform URL encoding and its decoding.</dd>
<dt><code>tcucodec base [-d] [<var>file</var>]</code></dt>
<dd>Perform Base64 encoding and its decoding.</dd>
<dt><code>tcucodec quote [-d] [<var>file</var>]</code></dt>
<dd>Perform quoted-printable encoding and its decoding.</dd>
<dt><code>tcucodec mime [-d] [-en <var>name</var>] [-q] [<var>file</var>]</code></dt>
<dd>Perform MIME encoding and its decoding.</dd>
<dt><code>tcucodec pack [-d] [-bwt] [<var>file</var>]</code></dt>
<dd>Perform Packbits encoding and its decoding.</dd>
<dt><code>tcucodec tcbs [-d] [<var>file</var>]</code></dt>
<dd>Perform TCBS encoding and its decoding.</dd>
<dt><code>tcucodec zlib [-d] [-gz] [<var>file</var>]</code></dt>
<dd>Perform ZLIB encoding and its decoding.</dd>
<dt><code>tcucodec xml [-d] [-br] [<var>file</var>]</code></dt>
<dd>Process XML.  By default, escape meta characters.</dd>
<dt><code>tcucodec conf [-v|-i|-l|-p]</code></dt>
<dd>Print some configurations.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-d</code> : perform decoding (unescaping), not encoding (escaping).</li>
<li><code>-br</code> : break up URL or XML into elements.</li>
<li><code>-rs <var>base</var></code> : specify the base URL and resolve the relative URL.</li>
<li><code>-en <var>name</var></code> : specify the input encoding, which is UTF-8 by default.</li>
<li><code>-q</code> : use quoted-printable encoding, which is Base64 by default.</li>
<li><code>-bwt</code> : convert by BWT as preprocessing.</li>
<li><code>-gz</code> : use GZIP format.</li>
<li><code>-v</code> : show the version number of Tokyo Cabinet.</li>
<li><code>-i</code> : show options to include the headers of Tokyo Cabinet.</li>
<li><code>-l</code> : show options to link the library of Tokyo Cabinet.</li>
<li><code>-p</code> : show the directory path of the commands of Tokyo Cabinet.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tchdbapi">The Hash Database API</h2>

<p>Hash database is a file containing a hash table and is handled with the hash database API.  See `<code>tchdb.h</code>' for entire specification.</p>

<h3>Description</h3>

<p>To use the hash database API, include `<code>tcutil.h</code>', `<code>tchdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tchdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCHDB</code>' are used to handle hash databases.  A hash database object is created with the function `<code>tchdbnew</code>' and is deleted with the function `<code>tchdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the hash database object to it.  The function `<code>tchdbopen</code>' is used to open a database file and the function `<code>tchdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.</p>

<h3>API</h3>

<p>The function `tchdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tchdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
</dl>

<p>The function `tchdbnew' is used in order to create a hash database object.</p>

<dl class="api">
<dt><code>TCHDB *tchdbnew(void);</code></dt>
<dd>The return value is the new hash database object.</dd>
</dl>

<p>The function `tchdbdel' is used in order to delete a hash database object.</p>

<dl class="api">
<dt><code>void tchdbdel(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tchdbecode' is used in order to get the last happened error code of a hash database object.</p>

<dl class="api">
<dt><code>int tchdbecode(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error code is defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tchdbsetmutex' is used in order to set mutual exclusion control of a hash database object for threading.</p>

<dl class="api">
<dt><code>bool tchdbsetmutex(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbtune' is used in order to set the tuning parameters of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbtune(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 16381.  Suggested size of the bucket array is about from 0.5 to 4 times of the number of all records to be stored.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 4 standing for 2^4=16.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tchdbopen' is used in order to open a database file and connect a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbopen(TCHDB *<var>hdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `HDBOWRITER' as a writer, `HDBOREADER' as a reader.  If the mode is `HDBOWRITER', the following may be added by bitwise or: `HDBOCREAT', which means it creates a new database if not exist, `HDBOTRUNC', which means it creates a new database regardless if one exists.  Both of `HDBOREADER' and `HDBOWRITER' can be added to by bitwise or: `HDBONOLCK', which means it opens the database file without file locking, or `HDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbclose' is used in order to close a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbclose(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tchdbput' is used in order to store a record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbput2' is used in order to store a string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbput2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>over</var>' specifies whether the value of the duplicated record is overwritten or not.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tchdbputkeep' is used in order to store a new record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputkeep2' is used in order to store a new string record into a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputkeep2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tchdbputcat' is used in order to concatenate a value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputcat2' is used in order to concatenate a string value at the end of the existing record in a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbputcat2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tchdbputasync' is used in order to store a record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbputasync2' is used in order to store a string record into a hash database object in asynchronous fashion.</p>

<dl class="api">
<dt><code>bool tchdbputasync2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.  Records passed to this function are accumulated into the inner buffer and wrote into the file at a blast.</dd>
</dl>

<p>The function `tchdbout' is used in order to remove a record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbout2' is used in order to remove a string record of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbout2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbget' is used in order to retrieve a record in a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbget(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget2' is used in order to retrieve a string record in a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbget2(TCHDB *<var>hdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tchdbget3' is used in order to retrieve a record in a hash database object and write the value into a buffer.</p>

<dl class="api">
<dt><code>int tchdbget3(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, void *<var>vbuf</var>, int <var>max</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the buffer into which the value of the corresponding record is written.</dd>
<dd>`<var>max</var>' specifies the size of the buffer.</dd>
<dd>If successful, the return value is the size of the written data, else, it is -1.  -1 is returned if no record corresponds to the specified key.</dd>
<dd>Note that an additional zero code is not appended at the end of the region of the writing buffer.</dd>
</dl>

<p>The function `tchdbvsiz' is used in order to get the size of the value of a record in a hash database object.</p>

<dl class="api">
<dt><code>int tchdbvsiz(TCHDB *<var>hdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
</dl>

<p>The function `tchdbiterinit' is used in order to initialize the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiterinit(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The iterator is used in order to access the key of every record stored in a database.</dd>
</dl>

<p>The function `tchdbiternext' is used in order to get the next key of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>void *tchdbiternext(TCHDB *<var>hdb</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  It is allowed to update or remove records whose keys are fetched while the iteration.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext2' is used in order to get the next key string of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>char *tchdbiternext2(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>If successful, the return value is the string of the next key, else, it is `NULL'.  `NULL' is returned when no record is to be get out of the iterator.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.  It is possible to access every record by iteration of calling this function.  However, it is not assured if updating the database is occurred while the iteration.  Besides, the order of this traversal access method is arbitrary, so it is not assured that the order of storing matches the one of the traversal access.</dd>
</dl>

<p>The function `tchdbiternext3' is used in order to get the next extensible objects of the iterator of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdbiternext3(TCHDB *<var>hdb</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the next key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the next value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when no record is to be get out of the iterator.</dd>
</dl>

<p>The function `tchdbsync' is used in order to synchronize updated contents of a hash database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tchdbsync(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects the same database file.</dd>
</dl>

<p>The function `tchdboptimize' is used in order to optimize the file of a hash database object.</p>

<dl class="api">
<dt><code>bool tchdboptimize(TCHDB *<var>hdb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is two times of the number of records.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `HDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `HDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `HDBTTCBS' specifies that each record is compressed with TCBS encoding.  If it is `UINT8_MAX', the default setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tchdbvanish' is used in order to remove all records of a hash database object.</p>

<dl>
<dt><code>bool tchdbvanish(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tchdbpath' is used in order to get the file path of a hash database object.</p>

<dl class="api">
<dt><code>const char *tchdbpath(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbrnum' is used in order to get the number of records of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbrnum(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tchdbfsiz' is used in order to get the size of the database file of a hash database object.</p>

<dl class="api">
<dt><code>uint64_t tchdbfsiz(TCHDB *<var>hdb</var>);</code></dt>
<dd>`<var>hdb</var>' specifies the hash database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<h3>Example Code</h3>

<p>The following code is an example to use a hash database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tchdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCHDB *hdb;
  int ecode;
  char *key, *value;

  /* create the object */
  hdb = tchdbnew();

  /* open the database */
  if(!tchdbopen(hdb, "casket.hdb", HDBOWRITER | HDBOCREAT)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "open error: %s\n", tchdberrmsg(ecode));
  }

  /* store records */
  if(!tchdbput2(hdb, "foo", "hop") ||
     !tchdbput2(hdb, "bar", "step") ||
     !tchdbput2(hdb, "baz", "jump")){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "put error: %s\n", tchdberrmsg(ecode));
  }

  /* retrieve records */
  value = tchdbget2(hdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tchdbecode(hdb);
    fprintf(stderr, "get error: %s\n", tchdberrmsg(ecode));
  }

  /* traverse records */
  tchdbiterinit(hdb);
  while((key = tchdbiternext2(hdb)) != NULL){
    value = tchdbget2(hdb, key);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
  }

  /* close the database */
  if(!tchdbclose(hdb)){
    ecode = tchdbecode(hdb);
    fprintf(stderr, "close error: %s\n", tchdberrmsg(ecode));
  }

  /* delete the object */
  tchdbdel(hdb);

  return 0;
}
</pre>

<h3>CLI</h3>

<p>To use the hash database API easily, the commands `<code>tchtest</code>', `<code>tchmttest</code>', and `<code>tchmgr</code>' are provided.</p>

<p>The command `<code>tchtest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tchtest write [-mt] [-tl] [-td|-tb] [-nl|-nb] [-as] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tchtest read [-mt] [-nl|-nb] [-wb] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tchtest remove [-mt] [-nl|-nb] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tchtest rcat [-mt] [-tl] [-td|-tb] [-nl|-nb] [-pn <var>num</var>] [-rl] <var>path</var> <var>rnum</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tchtest misc [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tchtest wicked [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tchdbsetmutex'.</li>
<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTTCBS'.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-as</code> : use the function `tchdbputasync' instead of `tchdbput'.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-rl</code> : set the length of values at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tchmttest</code>' is a utility for facility test under multi-thread situation.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tchmttest write [-tl] [-td|-tb] [-nl|-nb] [-as] path tnum rnum [bnum] [apow] [fpow]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tchmttest read [-nl|-nb] [-wb] path tnum</code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tchmttest remove [-nl|-nb] [-wb] path tnum</code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tchmttest wicked [-tl] [-td|-tb] [-nl|-nb] [-nc] path tnum rnum</code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTTCBS'.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-as</code> : use the function `tchdbputasync' instead of `tchdbput'.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tchmgr</code>' is a utility for test and debugging of the hash database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.</p>

<dl class="api">
<dt><code>tchmgr create [-tl] [-td|-tb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tchmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tchmgr put [-nl|-nb] [-sx] [-dk|-dc] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tchmgr out [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tchmgr get [-nl|-nb] [-sx] [-px] [-nl] <var>path</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tchmgr list [-nl|-nb] [-pv] <var>path</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tchmgr optimize [-tl] [-td|-tb] [-tz] [-nl|-nb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tchmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">

<li><code>-tl</code> : enable the option `HDBTLARGE'.</li>
<li><code>-td</code> : enable the option `HDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `HDBTTCBS'.</li>
<li><code>-nl</code> : enable the option `HDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `HDBLCKNB'.</li>
<li><code>-sx</code> : input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tchdbputkeep' instead of `tchdbput'.</li>
<li><code>-dc</code> : use the function `tchdbputcat' instead of `tchdbput'.</li>
<li><code>-px</code> : output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-pv</code> : print values of record also.</li>
<li><code>-tz</code> : enable the option `UINT8_MAX'.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="tcbdbapi">The B+ tree database API</h2>

<p>B+ tree database is a file containing a B+ tree and is handled with the B+ tree database API.  See `<code>tcbdb.h</code>' for entire specification.</p>

<h3>Description</h3>

<p>To use the B+ tree database API, include `<code>tcutil.h</code>', `<code>tchdb.h</code>', `<code>tcbdb.h</code>', and related standard header files.  Usually, write the following description near the front of a source file.</p>

<dl>
<dt><code>#include &lt;tcutil.h&gt;</code></dt>
<dt><code>#include &lt;tchdb.h&gt;</code></dt>
<dt><code>#include &lt;tcbdb.h&gt;</code></dt>
<dt><code>#include &lt;stdlib.h&gt;</code></dt>
<dt><code>#include &lt;stdbool.h&gt;</code></dt>
<dt><code>#include &lt;stdint.h&gt;</code></dt>
</dl>

<p>Objects whose type is pointer to `<code>TCBDB</code>' are used to handle B+ tree databases.  A B+ tree database object is created with the function `<code>tcbdbnew</code>' and is deleted with the function `<code>tcbdbdel</code>'.  To avoid memory leak, it is important to delete every object when it is no longer in use.</p>

<p>Before operations to store or retrieve records, it is necessary to open a database file and connect the B+ tree database object to it.  The function `<code>tcbdbopen</code>' is used to open a database file and the function `<code>tcbdbclose</code>' is used to close the database file.  To avoid data missing or corruption, it is important to close every database file when it is no longer in use.</p>

<h3>API</h3>

<p>The function `tcbdberrmsg' is used in order to get the message string corresponding to an error code.</p>

<dl class="api">
<dt><code>const char *tcbdberrmsg(int <var>ecode</var>);</code></dt>
<dd>`<var>ecode</var>' specifies the error code.</dd>
</dl>

<p>The function `tcbdbnew' is used in order to create a B+ tree database object.</p>

<dl class="api">
<dt><code>TCBDB *tcbdbnew(void);</code></dt>
<dd>The return value is the new B+ tree database object.</dd>
</dl>

<p>The function `tcbdbdel' is used in order to delete a B+ tree database object.</p>

<dl class="api">
<dt><code>void tcbdbdel(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If the database is not closed, it is closed implicitly.  Note that the deleted object and its derivatives can not be used anymore.</dd>
</dl>

<p>The function `tcbdbecode' is used in order to get the last happened error code of a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbecode(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the last happened error code.</dd>
<dd>The following error code is defined: `TCESUCCESS' for success, `TCETHREAD' for threading error, `TCEINVALID' for invalid operation, `TCENOFILE' for file not found, `TCENOPERM' for no permission, `TCEMETA' for invalid meta data, `TCERHEAD' for invalid record header, `TCEOPEN' for open error, `TCECLOSE' for close error, `TCETRUNC' for trunc error, `TCESYNC' for sync error, `TCESTAT' for stat error, `TCESEEK' for seek error, `TCEREAD' for read error, `TCEWRITE' for write error, `TCEMMAP' for mmap error, `TCELOCK' for lock error, `TCEUNLINK' for unlink error, `TCERENAME' for rename error, `TCEMKDIR' for mkdir error, `TCERMDIR' for rmdir error, `TCEKEEP' for existing record, `TCENOREC' for no record found, and `TCEMISC' for miscellaneous error.</dd>
</dl>

<p>The function `tcbdbsetmutex' is used in order to set mutual exclusion control of a B+ tree database object for threading.</p>

<dl class="api">
<dt><code>bool tcbdbsetmutex(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the mutual exclusion control of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcmpfunc' is used in order to set the custom comparison function of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcmpfunc(TCBDB *<var>bdb</var>, BDBCMP <var>cmp</var>, void *<var>cmpop</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>cmp</var>' specifies the pointer to the custom comparison function.</dd>
<dd>`<var>cmpop</var>' specifies an arbitrary pointer to be given as a parameter of the comparison function.  If it is not needed, `NULL' can be specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The default comparison function compares keys of two records by lexical order.  The functions `tcbdbcmplexical' (dafault), `tcbdbcmpdecimal', `tcbdbcmpint32', and `tcbdbcmpint64' are built-in.  Note that the comparison function should be set before the database is opened.  Moreover, user-defined comparison functions should be set every time the database is being opened.</dd>
</dl>

<p>The function `tcbdbtune' is used in order to set the tuning parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtune(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the default value is specified.  The default value is 128.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the default value is specified.  The default value is 256.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the default value is specified.  The default value is 16381.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the default value is specified.  The default value is 8 standing for 2^8=256.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the default value is specified.  The default value is 10 standing for 2^10=1024.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each page is compressed with Deflate encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbsetcache' is used in order to set the caching parameters of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbsetcache(TCBDB *<var>bdb</var>, int32_t <var>lcnum</var>, int32_t <var>ncnum</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>lcnum</var>' specifies the maximum number of leaf nodes to be cached.  If it is not more than 0, the default value is specified.</dd>
<dd>`<var>ncnum</var>' specifies the maximum number of non-leaf nodes to be cached.  If it is not more than 0, the default value is specified.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Note that the tuning parameters of the database should be set before the database is opened.</dd>
</dl>

<p>The function `tcbdbopen' is used in order to open a database file and connect a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbopen(TCBDB *<var>bdb</var>, const char *<var>path</var>, int <var>omode</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object which is not opened.</dd>
<dd>`<var>path</var>' specifies the path of the database file.</dd>
<dd>`<var>omode</var>' specifies the connection mode: `BDBOWRITER' as a writer, `BDBOREADER' as a reader.  If the mode is `BDBOWRITER', the following may be added by bitwise or: `BDBOCREAT', which means it creates a new database if not exist, `BDBOTRUNC', which means it creates a new database regardless if one exists.  Both of `BDBOREADER' and `BDBOWRITER' can be added to by bitwise or: `BDBONOLCK', which means it opens the database file without file locking, or `BDBOLCKNB', which means locking is performed without blocking.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbclose' is used in order to close a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbclose(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update of a database is assured to be written when the database is closed.  If a writer opens a database but does not close it appropriately, the database will be broken.</dd>
</dl>

<p>The function `tcbdbput' is used in order to store a record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbput2' is used in order to store a string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbput2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>over</var>' specifies whether the value of the duplicated record is overwritten or not.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, it is overwritten.</dd>
</dl>

<p>The function `tcbdbputkeep' is used in order to store a new record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputkeep2' is used in order to store a new string record into a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputkeep2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, this function has no effect.</dd>
</dl>

<p>The function `tcbdbputcat' is used in order to concatenate a value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputcat2' is used in order to concatenate a string value at the end of the existing record in a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbputcat2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If there is no corresponding record, a new record is created.</dd>
</dl>

<p>The function `tcbdbputdup' is used in order to store a record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const void *<var>vbuf</var>, int <var>vsiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup2' is used in order to store a string record into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>, const char *<var>vstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new record is placed after the existing one.</dd>
</dl>

<p>The function `tcbdbputdup3' is used in order to store records into a B+ tree database object with allowing duplication of keys.</p>

<dl class="api">
<dt><code>bool tcbdbputdup3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, const TCLIST *<var>vals</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the common key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the common key.</dd>
<dd>`<var>vals</var>' specifies a list object containing values.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If a record with the same key exists in the database, the new records are placed after the existing one.</dd>
</dl>

<p>The function `tcbdbout' is used in order to remove a record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.</dd>
</dl>

<p>The function `tcbdbout2' is used in order to remove a string record of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.</dd>
</dl>

<p>The function `tcbdbout3' is used in order to remove records of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbout3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>If the key of duplicated records is specified, all of them are removed.</dd>
</dl>

<p>The function `tcbdbget' is used in order to retrieve a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>void *tcbdbget(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget2' is used in order to retrieve a string record in a B+ tree database object.</p>

<dl class="api">
<dt><code>char *tcbdbget2(TCBDB *<var>bdb</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is the string of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbget3' is used in order to retrieve a record in a B+ tree database object as a volatile buffer.</p>

<dl class="api">
<dt><code>const void *tcbdbget3(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value of the corresponding record.  `NULL' is returned if no record corresponds.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.  Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbget4' is used in order to retrieve records in a B+ tree database object.</p>

<dl class="api">
<dt><code>TCLIST *tcbdbget4(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is a list object of the values of the corresponding records.  `NULL' is returned if no record corresponds.</dd>
<dd>Because the object of the return value is created with the function `tclistnew', it should be deleted with the function `tclistdel' when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbvnum' is used in order to get the number of records corresponding a key in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvnum(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the number of the corresponding records, else, it is 0.</dd>
</dl>

<p>The function `tcbdbvsiz' is used in order to get the size of the value of a record in a B+ tree database object.</p>

<dl class="api">
<dt><code>int tcbdbvsiz(TCBDB *<var>bdb</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is the size of the value of the corresponding record, else, it is -1.</dd>
<dd>If the key of duplicated records is specified, the value of the first record is selected.</dd>
</dl>

<p>The function `tcbdbsync' is used in order to synchronize updated contents of a B+ tree database object with the file and the device.</p>

<dl class="api">
<dt><code>bool tcbdbsync(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful when another process connects the same database file.</dd>
</dl>

<p>The function `tcbdboptimize' is used in order to optimize the file of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdboptimize(TCBDB *<var>bdb</var>, int32_t <var>lmemb</var>, int32_t <var>nmemb</var>, int64_t <var>bnum</var>, int8_t <var>apow</var>, int8_t <var>fpow</var>, uint8_t <var>opts</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>`<var>lmemb</var>' specifies the number of members in each leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>nmemb</var>' specifies the number of members in each non-leaf page.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>bnum</var>' specifies the number of elements of the bucket array.  If it is not more than 0, the current setting is not changed.</dd>
<dd>`<var>apow</var>' specifies the size of record alignment by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>fpow</var>' specifies the maximum number of elements of the free block pool by power of 2.  If it is negative, the current setting is not changed.</dd>
<dd>`<var>opts</var>' specifies options by bitwise or: `BDBTLARGE' specifies that the size of the database can be larger than 2GB by using 64-bit bucket array, `BDBTDEFLATE' specifies that each record is compressed with Deflate encoding, `BDBTTCBS' specifies that each page is compressed with TCBS encoding.  If it is `UINT8_MAX', the default setting is not changed.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>This function is useful to reduce the size of the database file with data fragmentation by successive updating.</dd>
</dl>

<p>The function `tcbdbvanish' is used in order to remove all records of a B+ tree database object.</p>

<dl>
<dt><code>bool tcbdbvanish(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
</dl>

<p>The function `tcbdbtranbegin' is used in order to begin the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranbegin(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>The database is locked by the thread while the transaction so that only one transaction can be activated with a database object at the same time.  Thus, the serializable isolation level is assumed if every database operation is performed in the transaction.  If the database is closed during transaction, the transaction is aborted implicitly.</dd>
</dl>

<p>The function `tcbdbtrancommit' is used in order to commit the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtrancommit(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is fixed when it is committed successfully.</dd>
</dl>

<p>The function `tcbdbtranabort' is used in order to abort the transaction of a B+ tree database object.</p>

<dl class="api">
<dt><code>bool tcbdbtranabort(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object connected as a writer.</dd>
<dd>If successful, the return value is true, else, it is false.</dd>
<dd>Update in the transaction is discarded when it is aborted.  The state of the database is rollbacked to before transaction.</dd>
</dl>

<p>The function `tcbdbpath' is used in order to get the file path of a B+ tree database object.</p>

<dl class="api">
<dt><code>const char *tcbdbpath(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the path of the database file or `NULL' if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbrnum' is used in order to get the number of records of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbrnum(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the number of records or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbfsiz' is used in order to get the size of the database file of a B+ tree database object.</p>

<dl class="api">
<dt><code>uint64_t tcbdbfsiz(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the size of the database file or 0 if the object does not connect to any database file.</dd>
</dl>

<p>The function `tcbdbcurnew' is used in order to create a cursor object.</p>

<dl class="api">
<dt><code>BDBCUR *tcbdbcurnew(TCBDB *<var>bdb</var>);</code></dt>
<dd>`<var>bdb</var>' specifies the B+ tree database object.</dd>
<dd>The return value is the new cursor object.</dd>
<dd>Note that the cursor is available only after initialization with the `tcbdbcurfirst' or the `tcbdbcurjump' functions and so on.  Moreover, the position of the cursor will be indefinite when the database is updated after the initialization of the cursor.</dd>
</dl>

<p>The function `tcbdbcurdel' is used in order to delete a cursor object.</p>

<dl class="api">
<dt><code>void tcbdbcurdel(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
</dl>

<p>The function `tcbdbcurfirst' is used in order to move a cursor object to the first record.</p>

<dl class="api">
<dt><code>bool tcbdbcurfirst(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurlast' is used in order to move a cursor object to the last record.</p>

<dl class="api">
<dt><code>bool tcbdbcurlast(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record in the database.</dd>
</dl>

<p>The function `tcbdbcurjump' is used in order to move a cursor object to the front of records corresponding a key.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump(BDBCUR *<var>cur</var>, const void *<var>kbuf</var>, int <var>ksiz</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kbuf</var>' specifies the pointer to the region of the key.</dd>
<dd>`<var>ksiz</var>' specifies the size of the region of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurjump2' is used in order to move a cursor object to the front of records corresponding a key string.</p>

<dl class="api">
<dt><code>bool tcbdbcurjump2(BDBCUR *<var>cur</var>, const char *<var>kstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kstr</var>' specifies the string of the key.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no record corresponding the condition.</dd>
<dd>The cursor is set to the first record corresponding the key or the next substitute if completely matching record does not exist.</dd>
</dl>

<p>The function `tcbdbcurprev' is used in order to move a cursor object to the previous record.</p>

<dl class="api">
<dt><code>bool tcbdbcurprev(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no previous record.</dd>
</dl>

<p>The function `tcbdbcurnext' is used in order to move a cursor object to the next record.</p>

<dl class="api">
<dt><code>bool tcbdbcurnext(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned if there is no next record.</dd>
</dl>

<p>The function `tcbdbcurput' is used in order to insert a record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput(BDBCUR *<var>cur</var>, const void *<var>vbuf</var>, int <var>vsiz</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vbuf</var>' specifies the pointer to the region of the value.</dd>
<dd>`<var>vsiz</var>' specifies the size of the region of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurput2' is used in order to insert a string record around a cursor object.</p>

<dl class="api">
<dt><code>bool tcbdbcurput2(BDBCUR *<var>cur</var>, const char *<var>vstr</var>, int <var>cpmode</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>`<var>vstr</var>' specifies the string of the value.</dd>
<dd>`<var>cpmode</var>' specifies detail adjustment: `BDBCPCURRENT', which means that the value of the current record is overwritten, `BDBCPBEFORE', which means that the new record is inserted before the current record, `BDBCPAFTER', which means that the new record is inserted after the current record.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After insertion, the cursor is moved to the inserted record.</dd>
</dl>

<p>The function `tcbdbcurout' is used in order to delete the record where a cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurout(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object of writer connection.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
<dd>After deletion, the cursor is moved to the next record if possible.</dd>
</dl>

<p>The function `tcbdbcurkey' is used in order to get the key of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey2' is used in order to get the key string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurkey2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurkey3' is used in order to get the key of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const char *tcbdbcurkey3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the key, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurval' is used in order to get the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval2' is used in order to get the value string of the record where the cursor object is.</p>

<dl class="api">
<dt><code>char *tcbdbcurval2(BDBCUR *<var>cur</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>If successful, the return value is the string of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because the region of the return value is allocated with the `malloc' call, it should be released with the `free' call when it is no longer in use.</dd>
</dl>

<p>The function `tcbdbcurval3' is used in order to get the value of the record where the cursor object is, as a volatile buffer.</p>

<dl class="api">
<dt><code>const char *tcbdbcurval3(BDBCUR *<var>cur</var>, int *<var>sp</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>sp</var>' specifies the pointer to the variable into which the size of the region of the return value is assigned.</dd>
<dd>If successful, the return value is the pointer to the region of the value, else, it is `NULL'.  `NULL' is returned when the cursor is at invalid position.</dd>
<dd>Because an additional zero code is appended at the end of the region of the return value, the return value can be treated as a character string.  Because the region of the return value is volatile and it may be spoiled by another operation of the database, the data should be copied into another involatile buffer immediately.</dd>
</dl>

<p>The function `tcbdbcurrec' is used in order to get the key and the value of the record where the cursor object is.</p>

<dl class="api">
<dt><code>bool tcbdbcurrec(BDBCUR *<var>cur</var>, TCXSTR *<var>kxstr</var>, TCXSTR *<var>vxstr</var>);</code></dt>
<dd>`<var>cur</var>' specifies the cursor object.</dd>
<dd>`<var>kxstr</var>' specifies the object into which the key is wrote down.</dd>
<dd>`<var>vxstr</var>' specifies the object into which the value is wrote down.</dd>
<dd>If successful, the return value is true, else, it is false.  False is returned when the cursor is at invalid position.</dd>
</dl>

<h3>Example Code</h3>

<p>The following code is an example to use a B+ tree database.</p>

<pre>#include &lt;tcutil.h&gt;
#include &lt;tchdb.h&gt;
#include &lt;tcbdb.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char **argv){

  TCBDB *bdb;
  BDBCUR *cur;
  int ecode;
  char *key, *value;

  /* create the object */
  bdb = tcbdbnew();

  /* open the database */
  if(!tcbdbopen(bdb, "casket.bdb", BDBOWRITER | BDBOCREAT)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "open error: %s\n", tcbdberrmsg(ecode));
  }

  /* store records */
  if(!tcbdbput2(bdb, "foo", "hop") ||
     !tcbdbput2(bdb, "bar", "step") ||
     !tcbdbput2(bdb, "baz", "jump")){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "put error: %s\n", tcbdberrmsg(ecode));
  }

  /* retrieve records */
  value = tcbdbget2(bdb, "foo");
  if(value){
    printf("%s\n", value);
    free(value);
  } else {
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "get error: %s\n", tcbdberrmsg(ecode));
  }

  /* traverse records */
  cur = tcbdbcurnew(bdb);
  tcbdbcurfirst(cur);
  while((key = tcbdbcurkey2(cur)) != NULL){
    value = tcbdbcurval2(cur);
    if(value){
      printf("%s:%s\n", key, value);
      free(value);
    }
    free(key);
    tcbdbcurnext(cur);
  }
  tcbdbcurdel(cur);

  /* close the database */
  if(!tcbdbclose(bdb)){
    ecode = tcbdbecode(bdb);
    fprintf(stderr, "close error: %s\n", tcbdberrmsg(ecode));
  }

  /* delete the object */
  tcbdbdel(bdb);

  return 0;
}
</pre>

<h3>CLI</h3>

<p>To use the B+ tree database API easily, the commands `<code>tcbtest</code>', `<code>tcbmttest</code>', and `<code>tcbmgr</code>' are provided.</p>

<p>The command `<code>tcbtest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tcbtest write [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcbtest read [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] [-wb] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcbtest remove [-mt] [-cd|-ci|-cj] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcbtest rcat [-mt] [-cd|-ci|-cj] [-tl] [-td|-tb] [-lc <var>num</var>] [-nc <var>num</var>] [-nl|-nb] [-pn <var>num</var>] [-rl] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with partway duplicated keys using concatenate mode.</dd>
<dt><code>tcbtest misc [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform miscellaneous test of various operations.</dd>
<dt><code>tcbtest wicked [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-mt</code> : call the function `tchdbsetmutex'.</li>
<li><code>-cd</code> : use the comparison function `tcbdbcmpdecimal'.</li>
<li><code>-ci</code> : use the comparison function  `tcbdbcmpint32'.</li>
<li><code>-cj</code> : use the comparison function  `tcbdbcmpint64'.</li>
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTTCBS'.</li>
<li><code>-lc <var>num</var></code> : specify the number of cached leaf pages.</li>
<li><code>-nc <var>num</var></code> : specify the number of cached non-leaf pages.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-wb</code> : use the function `tcbdbget3' instead of `tcbdbget'.</li>
<li><code>-pn <var>num</var></code> : specify the number of patterns.</li>
<li><code>-rl</code> : set the length of values at random.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcbmttest</code>' is a utility for facility test and performance test.  This command is used in the following format.  `<var>path</var>' specifies the path of a database file.  `<var>rnum</var>' specifies the number of iterations.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.</p>

<dl class="api">
<dt><code>tcbmttest write [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var> [<var>lmemb</var> [<var>nmemb</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]]]</code></dt>
<dd>Store records with keys of 8 bytes.  They change as `00000001', `00000002'...</dd>
<dt><code>tcbmttest read [-mt] [-nl|-nb] [-wb] <var>path</var></code></dt>
<dd>Retrieve all records of the database above.</dd>
<dt><code>tcbmttest remove [-mt] [-nl|-nb] <var>path</var></code></dt>
<dd>Remove all records of the database above.</dd>
<dt><code>tcbmttest wicked [-mt] [-tl] [-td|-tb] [-nl|-nb] <var>path</var> <var>rnum</var></code></dt>
<dd>Perform updating operations selected at random.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTTCBS'.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-wb</code> : use the function `tchdbget3' instead of `tchdbget'.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<p>The command `<code>tcbmgr</code>' is a utility for test and debugging of the B+ tree database API and its applications.  `<var>path</var>' specifies the path of a database file.  `<var>lmemb</var>' specifies the number of members in each leaf page.  `<var>nmemb</var>' specifies the number of members in each non-leaf page.  `<var>bnum</var>' specifies the number of buckets.  `<var>apow</var>' specifies the power of the alignment.  `<var>fpow</var>' specifies the power of the free block pool.  `<var>key</var>' specifies the key of a record.  `<var>value</var>' specifies the value of a record.</p>

<dl class="api">
<dt><code>tcbmgr create [-cd|-ci|-cj] [-tl] [-td|-tb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Create a database file.</dd>
<dt><code>tcbmgr inform [-nl|-nb] <var>path</var></code></dt>
<dd>Print miscellaneous information to the standard output.</dd>
<dt><code>tcbmgr put [-cd|-ci|-cj] [-nl|-nb] [-sx] [-dk|-dc] <var>path</var> <var>key</var> <var>value</var></code></dt>
<dd>Store a record.</dd>
<dt><code>tcbmgr out [-cd|-ci|-cj] [-nl|-nb] [-sx] <var>path</var> <var>key</var></code></dt>
<dd>Remove a record.</dd>
<dt><code>tcbmgr get [-cd|-ci|-cj] [-nl|-nb] [-sx] [-px] [-pz] <var>path</var> <var>key</var></code></dt>
<dd>Print the value of a record.</dd>
<dt><code>tcbmgr list [-cd|-ci|-cj] [-nl|-nb] [-pv] <var>path</var></code></dt>
<dd>Print keys of all records, separated by line feeds.</dd>
<dt><code>tcbmgr optimize [-cd|-ci|-cj] [-tl] [-td|-tb] [-tz] [-nl|-nb] <var>path</var> [<var>bnum</var> [<var>apow</var> [<var>fpow</var>]]]</code></dt>
<dd>Optimize a database file.</dd>
<dt><code>tcbmgr version</code></dt>
<dd>Print the version information of Tokyo Cabinet.</dd>
</dl>

<p>Options feature the following.</p>

<ul class="options">
<li><code>-cd</code> : use the comparison function `tcbdbcmpdecimal'.</li>
<li><code>-ci</code> : use the comparison function  `tcbdbcmpint32'.</li>
<li><code>-cj</code> : use the comparison function  `tcbdbcmpint64'.</li>
<li><code>-tl</code> : enable the option `BDBTLARGE'.</li>
<li><code>-td</code> : enable the option `BDBTDEFLATE'.</li>
<li><code>-tb</code> : enable the option `BDBTTCBS'.</li>
<li><code>-nl</code> : enable the option `BDBNOLCK'.</li>
<li><code>-nb</code> : enable the option `BDBLCKNB'.</li>
<li><code>-sx</code> : input data is evaluated as a hexadecimal data string.</li>
<li><code>-dk</code> : use the function `tchdbputkeep' instead of `tchdbput'.</li>
<li><code>-dc</code> : use the function `tchdbputcat' instead of `tchdbput'.</li>
<li><code>-px</code> : output data is converted into a hexadecimal data string.</li>
<li><code>-pz</code> : do not append line feed at the end of the output.</li>
<li><code>-pv</code> : print values of record also.</li>
<li><code>-tz</code> : enable the option `UINT8_MAX'.</li>
</ul>

<p>This command returns 0 on success, another on failure.</p>

<hr />

<h2 id="license">License</h2>

<p>Tokyo Cabinet is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License or any later version.</p>

<p>Tokyo Cabinet is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.</p>

<p>You should have received a copy of the GNU Lesser General Public License along with Tokyo Cabinet (See the file `<code>COPYING</code>'); if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</p>

<p>Tokyo Cabinet was written by Mikio Hirabayashi.  You can contact the author by e-mail to `<code>mikio@users.sourceforge.net</code>'.</p>

<hr />

</body>

</html>

<!-- END OF FILE -->
